# 闭包

## 作用域

```js
var name = 'qingsds'

//在我们看来这一句声明,但在js引擎中确是两个声明
var name (编译时处理)
name = 'qingsds' (运行时处理)

```

事实上,js也有编译阶段,跟传统的语言区别在于,js不会早早的把编译工作完成.而是一边编译一边执行,所有的js代码片段在执行前都会被编译,只是编译的过程非常短暂,紧接着这段代码被执行.

编译阶段和执行阶段发生了什么?

- 编译阶段: **编译器**会找遍当前作用域,看看有没有name,如果有name,就忽略`var name`这个声明,继续编译下去,如果没有,则在作用域新增一个name,然后**编译器**会为引擎生成所需要的代码,程序进入执行阶段.
- 执行阶段: 会有一个**js引擎**,js引擎在执行时,仍会找遍当前的作用域.看看有没有name,如果有则直接赋值,若没有,会从当前作用域"探出头",看看"外边"有没有,或者"外边的外边"有没有,若最终仍找不到name,js引擎会抛出一个异常.

js查找的过程中"探出头","到外边看看",就是js作用域中的作用域链.
**作用域套作用域,就有了作用域链**,作用域的本质就是程序**储存和访问变量的规则**.
在js中目前有三种作用域

- 全局作用域
- 函数作用域
- 块作用域

### 全局作用域

声明在任何函数之外的顶层作用域的变量就是全局变量，这样的变量拥有全局作用域

```js

var name = 'qingsds' //全局作用域内的变量

// 函数作用域
function show(){
  console.log(name)
}
// 块级作用域
{
  name = 'dou'
}

show(); //输出 'dou'

```

### 函数作用域

在函数内部定义的变量,拥有函数作用域

```js
var name = 'qingsds'; // name 是全局变量
function showName(myName) {
  // myName 是传入 showName 的局部变量
  console.log(myName);
}
function sayHello() {
  // hello 被定义成局部作用域变量
  var helloString = 'hello everyone';
  console.log(helloString);
}


showName(name); // 输出 'qingsds'
sayHello(); // 输出 'hello everyone'
console.log(myName); // 抛出错误：myName 在全局作用域未定义
console.log(helloString); // 抛出错误：hello 在全局作用域未定义

{
  console.log(helloString, myName) // 抛出错误
}
```

myName 和 hello 都是在函数内部定义的变量.作用域仅局限于函数内部。全局作用域和块作用域里都访问不到它们.

### 块级作用域

`let`和`const`关键字定义的变量,如果被`{}`包住,大括号包住的这些变量就形成了块级作用域.

