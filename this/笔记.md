# this 相关知识点

多数情况下,this 指向调用它所在**方法**的那个**对象**(谁调用的函数,this 就指向谁),所以 this 的指向是在调用时决定的

## 区分声明位置和调用位置

相对简单的例子

```js
var me = {
  stringName: "qingsds",
  hello: function () {
    console.log(`hello,I am ${this.stringName}`);
  },
};

var you = {
  stringName: "dou",
  hello: me.hello,
};

var stringName = "xiaopeng";
var hello = me.hello;

// 调用位置
me.hello(); //hello,I am qingsds
you.hello(); //hello,I am dou
hello(); //hello,I am xiaopeng
```

相对有难度的例子

```js
var me = {
  name: "qingsds",
  hello: function () {
    console.log(`hello, I am ${this.name}`);
  },
};

var you = {
  name: "xiaopeng",
  hello: function () {
    targetFunc = me.hello;
    // 此时方法被调用时没有任何对象前缀,所以默认指向window全局对象
    targetFunc();
  },
};

var name = "dou";
you.hello(); //hello, I am dou
```

## 特殊情况下的 this 指向

- 以下三种情况 this 百分百指向 window
  - 立即执行函数(IIFE)
  - setTimeout 中传入的函数
  - setInterval 中传入的函数

### 立即执行函数

```js var name = 'focus';
var me = {
  name: "qingsds",
  // 声明位置
  sayHello: function () {
    console.log(`hi, i am ${this.name}`);
  },
  hello: function () {
    (function (callback) {
      // 调用位置
      callback();
    })(this.sayHello);
  },
};

me.hello(); //hi, i am focus
```

其实原理还是一样 callback 被调用的时候,前面并没有任何对象前缀,默认指向 window

### setTimeout 和 setInterval 中传入的函数

```js
var name = "window";
var me = {
  name: "qingsds",
  hello: function () {
    setTimeout(function () {
      console.log(`hi, i am ${this.name}`);
    });
  },
};
me.hello(); //hi, i am window
```

setTimeout 和 setInterval,都是在全局作用域下实现的,无论是 setTimeout 还是 setInterval 里传入的参数,都会首先交付到全局对象上,因此 函数中 this 的指向是 window

## 严格模式下 this 的指向

### 普通函数中 this 在严格模式下的表现

普通函数:非"箭头函数"

```js
function showThis() {
  console.log(this);
}
showThis(); //输出window对象

("use strict");
function showThis() {
  console.log(this);
}
showThis(); //undefined
```

### 全局代码中的 this 在严格模式下的表现

```js
"use strict";
console.log(this); //window 对象
```

```js
"use strict";
var name = "window";
var me = {
  name: "qingsds",
  hello: function () {
    setTimeout(function () {
      console.log(`hi, i am ${this.name}`);
    });
  },
};
me.hello(); //hi, i am window
```

全局代码中的 this,不管是否处于严格模式,this 都是指向全局 window.

### 箭头函数

箭头函数中的 this 比较特别,它在"严格模式"和"非严格模式"下没有区别,和闭包很相似. 都是认"词法作用域",箭头函数中的 this,和如何调用它无关,由书写的位置决定.就是**定义该函数时所在的作用域指向的对象**,而不是使用时所在的作用域指向的对象。

例子:

```js
var name = "window";
var me = {
  name: "qingsds",
  // 声明的位置
  hello: () => {
    console.log(this.name);
  },
};
// 调用的位置
me.hello(); //window
```

为甚么是 window? **"该函数所在的作用域指向的对象"** ,作用域是指函数内部,这里的箭头函数,也就是 hello,所在的作用域是最外层的 JS 环境,因为没有其他函数包裹,然后最外层 JS 对象指向的对象是 window 对象,所以,这里的对象是 window 对象

使用箭头函数需要注意的其他几点:

- 不可以当做构造函数,也就是不能使用 new
- 不可以使用`arguments`对象，该对象在函数体内不存在,如果需要用 rest 代替
- 不可以使用`yield`命令,因此箭头函数不能用作`Generator`函数
